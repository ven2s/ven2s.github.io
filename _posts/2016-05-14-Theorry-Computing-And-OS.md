---
layout: post
comments: true
# other options
title:  "[이론] 컴퓨터의 연산 와 운영체제"
date:   2016-05-13 20:41:00
categories: [Study]
tags: [공부해서남주기, 이론, 컴퓨터기초]
---

* 이 포스팅은 개인적으로 공부했던 자료를 조사하고 정리한 자료 입니다. 최대한 정확하게 작성하려고 하였습니다.

# 컴퓨터의 연산

전 포스팅에서 컴퓨터는 0과 1로 연산을 한다고 언급을 한적이 있다.

역시 그렇다 컴퓨터는 연산을 할때 2진법을 이용해서 계산을 한다.  그럼 컴퓨터는 0과 1을 어떻게 사용을 해서 연산을 하게 되는 것인가?

이번 포스팅은 컴퓨터가 하는 연산 방법중 가장 많이 쓰는 연산에 대해서 언급을 할까 한다.
<br><br>

컴퓨터의 연산은 CPU안에 있는 **가산기(덧셈을 하는 논리회로)**를 통해서 처리를 하게 된다.

일반적으로 우리가 생각하는 사칙연산(더하기,빼기,곱하기,나누기)을 컴퓨터는 덧셈으로만 처리를 한다.

갑자기 뜬금없이 왠 덧셈으로만 연산을 한다는게 무슨 소리일까 싶을 것 같다.

컴퓨터는 0과 1밖에 구분을 못하고 2진수를 이용한 연산 밖에 못한다.(설명은 쉽게 하기 위해서 4bit 기준으로 이야기를 하도록 할꼐요)

여기서 우리가 보고 가야 할것은 컴퓨터는 수를 어떻게 표현하지 그리고 음수는 또 어떻게 표현 하나가 중요하다.

컴퓨터는 비트의 가장 앞자리를 부호를 위한 자리로 사용한다. 즉, 음수와 양수를 구분하는 비트표현 1자리 3자리는 수를 표현한다 (4bit기준)


0000 은 10진수면 0이고 0001 은 1, 0010은 2 이렇게 연산이 되는데 1000은 과연 어떻게 나올까?

대부분 아마 8을 생각을 하겠지만 사실 연산을 해보면 -8이 찍힌다. ??? 뜬금없는 소리지 하겠지만 앞서 말했듯이

이 표로 설명을 하면 4비트 기준으로 첫째 1비트는 부호(양수는 0 음수는 1)을 표현하고 나머지는 수를 표현하도록 한것이다.
그렇기 때문에 저 값은 -8 값이 나오게 된다 1001 은 -1 이라고 보면 된다.

자 그럼 컴퓨터가 **덧셈밖에 못하는 바보**같은 녀석인데 어떻게 연산을 하게 되는 것인가? 의문이 들것이다.

    예제)
       3 + 2 = 5 

           0011
       &   0010
    -------------
           0101

덧셈의 규칙
1) 1과 1일경우 한 자리수를 올린다
2) 1과 0일경우 1이 남는다
3) 비트 범위를 벗어날 경우 앞자리를 버린다

<table>
  <tr>
    <th style="color: red">1</th>
    <th style="background: #8bb3f4">0</th>
    <th style="background: #8bb3f4">0</th>
    <th style="background: #8bb3f4">0</th>
    <th style="background: #8bb3f4">0</th>
  </tr>
</table>   


 4비트 기준으로 연산을 하였을때 위에와 같이 1비트가 나오게 될경우 앞자리는 없애버리는 것이다.

자 다시 한번 연산을 해보도록 하자 1과 7을 덧셈을 하면 아래와 같이 나온다. 
```
     0001        1
   & 0111      + 7
-----------  ------
     1000      - 8
```
위와 같이 참으로 예쁘게(거지 같이) 계산이 된다.  ?????? 이게 왠 (개소리)헛소리인가 싶겟지만
실제 컴퓨터는 연산을 위에 와 같이 연산을 해준다.

그이유는 맨 앞자리는 **부호를 위한 비트**이기 때문이다.

<table>
  <tr>
    <th style="background-color: #f4c88b">1</th>
    <th>0</th>
    <th>0</th>
    <th>0</th>
  </tr>
</table>


그렇다면 뺄셈은 과연 어떻게 할까?

역시 뺄셈도 덧셈을 통해서 연산을 한다

단 2의 보수를 사용해서 연산을 한다 

즉 3 - 2 를 연산 하고자 한다면 3 + (-2) 로 하여서 계산을 하는 것이다.<br><br>

<table>
  <tr>
    <td style="background-color: #b7b7b7">0</td>
    <td>0000</td>
    <td style="background-color: #b7b7b7">0</td>
    <td>0000</td>
  </tr>
  <tr>
    <td style="background-color: #b7b7b7">1</td>
    <td>0001</td>
    <td style="background-color: #b7b7b7">-1</td>
    <td>1111</td>
  </tr>
  <tr>
    <td style="background-color: #b7b7b7">2</td>
    <td>0010</td>
    <td style="background-color: #b7b7b7">-2</td>
    <td>1010</td>
  </tr>
  <tr>
    <td style="background-color: #b7b7b7">3</td>
    <td>0011</td>
    <td style="background-color: #b7b7b7">-3</td>
    <td>1101</td>
  </tr>
  <tr>
    <td style="background-color: #b7b7b7">4</td>
    <td>0100</td>
    <td style="background-color: #b7b7b7">-4</td>
    <td>1100</td>
  </tr>
  <tr>
    <td style="background-color: #b7b7b7">5</td>
    <td>0101</td>
    <td style="background-color: #b7b7b7">-5</td>
    <td>1011</td>
  </tr>
  <tr>
    <td style="background-color: #b7b7b7">6</td>
    <td>0110</td>
    <td style="background-color: #b7b7b7">-6</td>
    <td>1010</td>
  </tr>
  <tr>
    <td style="background-color: #b7b7b7">7</td>
    <td>0111</td>
    <td style="background-color: #b7b7b7">-7</td>
    <td>1001</td>
  </tr>
  <tr>
     <td style="background-color: #b7b7b7">8</td>
    <td></td>
    <td style="background-color: #b7b7b7">-8</td>
    <td>1000</td>
  </tr>
</table>

<2의 보수>

2의 보수 구하는 방법

3을 보수를 구하려면 현재 비트를 반전을 시킨다
<table>
    <tr>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
    </tr>
</table>

(NOT)

<table>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>0</td>
    </tr>
</table>

 반전한 수에 1을 더한다.

<table>
    <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
    </tr>
</table>


다시 연산을 한다면 

          0011
       &  1101
    -------------
       1  0000     = 0000(2) = 0(10)


곱셈은 덧셈을 반복
나눗셈은 뺄셈을 반복 하는 방식으로
계산을 한다.

![논리연산](https://drive.google.com/uc?id=0B0K0Mz4r_akrQzJ5YkYxcG43bE0){: width="429px", height="512px"}<br>
< 논리연산 / 자료출처 : 모두의마음 블로그 ><br><br><br>



# 운영체제

## 운영체제는 왜 필요한가?
우리가 쓰는 컴퓨터에는 여러가지 장치가 있고, 이러한 장치들을 운용(혹은 사용)하려면 관리해주는 무언가가 필요하다.
세탁기, 전자레인지 등에 들어가는 소프트웨어(정확히는 펌웨어라고 한다)는 지정된 일만 하기때문에 따로 관리해줄 필요가 없다.
하지만 컴퓨터라는 것은 여러가지 장치들을 추가적으로 설치가 가능하고 이러한 장치들을 관리하고 사용 할 수 있게 그리고
관리 해주는 일을 하는 것이 운영체제의 일중의 하나이다.

## 운영체제의 종류
 운영체제는 여러가지가 있지만 크게 나누면 윈도우 계열 과 유닉스계열로 나뉠수 있다.

### 윈도우 계열
 - 마이크로소프트에서 만든 OS로서 많은 세계인들이 사용하는 OS이다. 
 - 윈도우는 안정성 보다는 범용성을 선택하였다.

### 유닉스 계열
 - 오랫동안 사용되온 운영체제이다. 비싸고 오래 사용 되어 왔기때문에 운영체제중에서는 가장 안정성이 확보된 운영체제로 보여지고 있다.

  * 리눅스는 리누스 토발즈가 유닉스와 비슷한 커널형 OS를 만들었다 그래서 유사 유닉스 OS(Unix likes OS)로 분리 한다.

### 운영체제의 역활

+ 시스템 관리 : 프로그램이 잘못된 명령 또는 자원을 사용을 하는지 감시 만약 잘못된 접근을 하거나 자원을 잘못 사용한다면 프로그램을 종료시킨다.

    ex)  윈도우의 블루스크린

+ (가상)시스템 서비스 제공 : 사용자가 컴퓨터를 쉽게 사용하게 환경을 제공
    
    ex) GUI(Grahpic User Interface) 

+ 자원관리 
    + 소프트웨어 및 하드웨어의 자원을 효율적으로 관리 및 보호
    + 한정된 자원을 관리하여 제공


## 운영체제의 자원 관리

### 프로세스 

: **실행이 되고 있는 프로그램을 일컫는다.**

![프로세스](https://drive.google.com/uc?id=0B0K0Mz4r_akrVTZQUmJyR1dlcE0){: width="460px", heigth="81px"}<br><br>

프로세스를 언급을 하게 되면 반드시 따라오는 개념이 스레드(Thread)이다. 추가적으로 테스크(Task)도 딸려와서 
헷갈리게 만드는 녀석이기도 하다.

 * 스레드(Thread) : 프로세스 안의 프로그램들의 흐름이 있는데 그 단위를 일컫는다. (= 수행의 단위)
 * 테스크(Task) : 자원소유권의 관리 단위

 프로세스 내부의 스레드가 존재하며 스레드당 하나의 일련의 흐름을 실행 시키게 된다.<br><br>
 
 ![스레드와 프로세스](https://drive.google.com/uc?id=0B0K0Mz4r_akrRnFXZGNMbXZxQUE){: width="250px", heigth="236px"}<br>
  <스레드와 프로세스 /출처 : 위키피디아(eng)><br><br>

위의 그림을 보면 프로세스 내부에 여러개의 스레드가 존재 할수 있다는걸 알수 있다.

즉, 스레드는 프로세스내부에 존재하는 연산을 병렬로 실행 시킴으로써 효율을 높이는 것이다.


여기서 또 하나 나오는 문제는 그럼 테스크는 무엇인가? 일것이다.

일반적인 이야기로는 이렇다. 스레드라는 개념이 나오기 이전에는 작업을 테스크라고 불리웠으나
스레드라는 개념이 나오면서 그 의미가 약간 흐려진것 같다.

일반적으로 이야기 하는 테스크와 스레드의 차이를 설명한다면 아래그림을 참조하자<br><br>

![멀티테스킹과 멀티스레딩](https://drive.google.com/uc?id=0B0K0Mz4r_akrX1l0X3dPVVJrbTg){: width="481px", height="140px"}<br>
< 멀티테스킹과 멀티스레딩 / 출처 : [델](http://www.dell.com/content/learnmore/learnmore.aspx?c=us&l=en&s=gen&~id=cpu&~line=workstations&~lt=popup&~series=precn) ><br><br>

위의 그림을 보면 분명한 차이가 존재하는데, **여러개의 어플리케이션(프로그램)을 동시에 실행 시키는것**을 **멀티테스킹**이라 한다.

예를 들어 웹서핑을 하면서 음악을 듣고, 친구와 메신저를 하는 것들을 이야기한다.

**멀티스레딩**은 앞서 이야기 했듯이 프로세스라는 현재 실행이 되고 있는 프로그램 내부의 여러개의 흐름을 통해 **동시다발적으로 연산**을 하는 것이라고 하면 맞을것 같다.


### 프로세스의 상태

 ![프로세스의 상태](https://drive.google.com/uc?id=0B0K0Mz4r_akrQ05McDZ2N1c4dnM){: width="407px", height="159"}<br>
 생성 : 프로세스를 생성
 
 준비 : CPU의해 실행되기 기다린다.
 
 실행 : 프로세스를 실행한다.(연산이 진행된다)
 
 대기 : 어떤 사건이 일어나길 기다린다.(혹은 사용자, 운영체제의 명령을 대기한다)
 
 종료 : 프로세스를 종료한다.

 * interupt : 예외 상황이 발생하여 대기 상태로 가는것을 말한다.
 * polling   : 오류사항을 체크하기 위해 주기적으로 체크 하는 것을 말한다.


### 프로세스 스케줄링

 - FCFS(First-Come First-Served) : 준비 상태 큐에 도착한 순서에 따라 차례로 CPU를 할당
 - SJF(Shortest Job First)
   * 실행시간이 가장 짧은 프로세스에게 먼저 할당 
   * 평균 대기시간이 가장 적은 알고리즘
   * 실행 시간이 긴 프로세스에 밀려 무한 연기 상태 발생가능
   * 1234번의 잡이 있었지만 3번이 가장 길다고 가정하에 4번이 선 수행 되었다 종료가 되었지만 다시 새로운 짧은 것이 들어 올경우 3번은 뒤로 밀려난다.

 - Round Robin Scheduling
      - 시분할 시스템을 위해 고안된 방식
      - FCFS 기법 변형
      - 각 프로세스는 시간 할당량 동안만 실행
      - 
 - Priority Based Scheduling
      - 프로세스마다 우선 순위 부여
      - 우선순위가 동일한 경우 FCFS기법 할당
      - 가장낮은 순위를 부여받은 프로세스가 처리 안되는 문제 발생

 - Multi Queue Scheduling
      - 프로세스를 특정 그룹으로 분류 할 수 있을 경우 그룹에 따라 각기 다른 준비 단계 큐 사용
      - 준비상태 큐 마다 다른 스케줄링 기법 사용가능
      - 다른 준비 상태 큐로 이동 불가
      - 하위 단계 준비 큐에 있는 프로세스를 실행하는 도중이라도 상위 단계 준비상태 큐에 프로세스가 들어오면 상위단계 프로세스에게 CPU할당

### 주기억장치관리

#### 단순관리

 가상메모리 : 보조기억장치를 주기억장치처럼 사용한다. (주기억장치가 비싸기 때문에 사용하지만 필요악이다)

 - 메모리를 자주 사용하는 부분이 있다면 맞지 않는다.
 - 캐시메모리 : 장치와 장치사이에 속도차이를 극복하기 위해서 만든 임시저장공간

#### 파일관리

 ![파일관리](https://drive.google.com/uc?id=0B0K0Mz4r_akrM0pFdUVkLXFrVUk){: width="407px", height="159"}

\* 운영체제마다 파일관리 시스템은 다르다
 <br><br>
<table>
 <tr>
     <th>운영체제종류</th>
     <th>파일관리시스템</th>
 </tr>
 <tr>
    <td>유닉스(Unix)</td>
    <td>Unix File System</td>
 </tr>
   <tr>
    <td>윈도우(Window)</td>
    <td>FAT32, NTFS</td>
 </tr>
   <tr>
    <td>맥(Mac OS)</td>
    <td>HFS, HGS+</td>
 </tr>
   <tr>
    <td>리눅스(Linux)</td>
    <td>확장파일관리시스템</td>
 </tr>
</table>

**파일시스템?** 파일을 관리하는 방법을 말한다. 근데 왜 다루는가? 바로 운영체제마다 파일시스템 규칙이 다르기 때문이다<br>

예) notepad.txt 라는 파일을 두고 두 운영체제에서 읽어 드릴때 차이는 아래와 같다

- 윈도우 : 파일이름 / 파일의 길이 가 기록이 되어 있어서 그 길이 만큼 읽어온다
- Mac OS: 파일내용 /파일의 이름 / 파일의 길이 가 기록이 되어 있어 그 길이 많큼 읽어 온다

차이점이 나게 되는 문제는 바로 기록의 방식이 운영시스템의 파일관리시스템 마다 다르게 되게 때문이다.


### 커널

운영체제에 있어서 커널의 존재는 아주 중요하다. **운영체제의 정체성** 이라고 표현을 할수 있을 정도이다.

**보안, 자원관리, 추상화**로 역활을 나눌 수 있다.<br><br>

![커널(kernel)](https://drive.google.com/uc?id=0B0K0Mz4r_akrU1Y1djNSUllOSTQ){: width="245px", heigth="194px"}<br>
< 커널 / 출처 : [위키엔드](http://www.wikiwand.com/ko/%EC%BB%A4%EB%84%90_(%EC%BB%B4%ED%93%A8%ED%8C%85)) > <br><br>

위의 그림을 보면 커널의 역활이 한눈에 보인다.

내가 생각하는 커널의 핵심은 바로 자원관리가 아닐까 생각을 한다. 

한정된 자원관리를 사용하기 편리하게 제공을 해준다. 

또한 스케줄링을 통해서 프로세스를 할당한다

그렇기 때문에 커널은 운영체제의 정체성이자 핵심이 라고 할 수 있다.


## 참고링크
 - 테스크와 스레드 ([http://talkingaboutme.tistory.com/454](http://talkingaboutme.tistory.com/454))
 - 컴퓨터의연산 ([http://www.slideshare.net/sunnykwak90/2-43573340](http://www.slideshare.net/sunnykwak90/2-43573340))