---
layout: post
comments: true
# other options
title:  "[이론] 자료구조와 알고리즘"
date:   2016-05-13 20:42:00
categories: [Study]
tags: [공부해서남주기, 이론, 컴퓨터기초]
---

**\* 이 포스팅은 개인적으로 공부했던 자료를 조사하고 정리한 자료 입니다. 최대한 정확하게 작성하려고 하였습니다.**

# 자료구조
<br><br>
**자료구조란?** 자료를 어떻게 효율적으로 자료를 저장할 지에대한 방법론이다.
<br><br>

자료구조는 알고리즘과 뗄수 없는 관련성을 지니고 있다. 자료구조와 알고리즘을 통해서 자료를 어떻게 사용할지에 대해서 정해지기 때문이다.

자료구조는 자료를 단순히 쌓기만 한다면 알고리즘을 통해서 사용한다면 빈 틈이 업이 효과적으로 사용 할수 있도록 할수가 있는것이다.

    ◼︎◻︎◼︎◻︎◼︎◻︎◼︎◻︎◼︎◻︎◼︎◻︎     =>    ◼︎◼︎◼︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎◻︎
    ◼︎◼︎◻︎◼︎◼︎◻︎◻︎◼︎◼︎◻︎◼︎◼︎     =>    ◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎◼︎

자료를 정리를 잘 하기 위한 것이라고 보면 된다


## 자료구조를 왜 배워야 하는가?

컴퓨터계열 전공자들이 가장 잊기도 쉽고 넘어가고 싶어 하는 부분이다. 엄청 어렵기도 하고 사실 이 블로그에서도 다 다루기는 힘들다.

하지만 가장 기초 되는 부분을 알고 넘어가야 한다. 어떻게 운영체제에서 사용이 되고 운용이 되는지 알아야 프로그램을 만들어도 잘 만들수 있고, 왜 이러한 현상이 일어 났는지에
대한 이해가 빠르기 때문이다. 

만약, 이부분을 넘어간다고 한다면 분명 후회 할 것이 분명하다. 나중에 머리가 굳어서 정립하기 보다 머리가 그나마 잘 돌아 갈때 정리를 해놓고 여러번 생각하면서 하기를 바란다. (지금 이글을 쓰고 있는 저도 그렇습니다...정리를 하기 위한 목적이니까요)


## 자료구조의 종류

원시, 선형, 비선형 구조 로 나뉜다.

원시는 정수, 실수, 문자 를 가지는 가장 기초적인 자료구조형태이다.

선형에는 배열, 연결리스트, 스택, 큐, 덱 과 같은 자료구조가 있다.

비선형에는 트리와 그래프라는 자료구조가 있다.

이 것들에 대해서 좀더 알아보는 시간을 가지려한다.

### 원시
이미언급 된바 있듯이 원시형은 가장 기초적인 것들이다. 

- 정수 : 우리가 일반적으로 사용하는 숫자들이다.(음수까지 포함된다)
- 실수 : 유리수, 무리수를 포함한 숫자들의 모음이다.
- 문자 : 인간이 말을 기록하기 위해서 만들어진 발명품으로 보면 편한다.

### 선형

#### 배열 
<br>
![배열](https://drive.google.com/uc?id=0B0K0Mz4r_akrVUlHVjFBQXg3cDQ){: width="400", heigth="145"}<br>
<배열 / 출처 : [mycolorworld](http://fxrank.co.kr/wp/%EA%B0%9D%EC%B2%B4%EB%B0%B0%EC%97%B4/) ><br><br>

배열이라고 하면 간단히 말하면  같은 종류들의 집합 이라고 이야기 할수 있다.

C언어로 예를 들면  **int array[10];**  는 정수형의 10개의 방을가진 집합 이라고 생각하면 된다.

위의 그림처럼 하나의 방에는 한개씩 데이터가 들어갈수 있게 된다.(정확하게는 정수형 int 형이 표현 할수 있는 수 만큼 들어간다)

그리고 각 방은 고유의 번호(=Index)가 있다. (호텔의 방번호라고 생각하면 된다)

이때 번호는 0부터 시작을 하게 되며 9까지 가지도록 되어 있다. (그림기준)


#### 연결리스트

<br>
![연결리스트](https://drive.google.com/uc?id=0B0K0Mz4r_akrQ2h1T0hyay1KblE){: width="349", heigth="249"}<br>
< 연결리스트 / 출처 : [윈플 님 블로그](http://winplz.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8Linked-List) ><br><br>

여러개의 구조체를 묶은 것을 리스트라고 한다. (배열은 처음부터 한묶음이지만 이녀석은 구조체들을 묶는다)
역시 한개의 형태(자료형)을 가지며, 다음 구조체에 대한 주소값을 가지고 있다.

배열과 다른 점은 배열은 처음부터 10개를 할당하고 그 내부가 지워져도 그대로 방이 존재하지만
연결리스트는 구조체 한개가 사라지면 자동으로 사라지는 구조체를 기준으로 전 구조체와 후 구조체가 연결이 되도록 되어 있다.

그래서 리스트는 데이터를 가지는 방과 그 후값을 가르키는 포인터를 가진 방으로 구성되어 있다.

 - 단방향 연결 리스트 : 한방향의 주소값을 가지고 있다(다음 자료의 주소값만 소유)
 - 양방향 연결 리스트 : 양방향의 주소값을 가지고 있다.(전 자료, 다음 자료의 주소값 가짐)
 - 환형 연결 리스트 : 양방향리스트에서 조금 다른 점은 가장 처음과 마지막 자료의 주소값이 이어져 있다는 것이다 (마치 원처럼)

#### 스택(Stack)

입력된 순서대로 쌓이는 구조로써 가장 마지막에 들어온 명령어가 먼저 종료되고 나가는 구조이다 (First-In Last-Out)
<br>
![stack](https://drive.google.com/uc?id=0B0K0Mz4r_akrZ0ltdkhNTXZlYk0){: width="300", heigth="216"}<br>
< stack / 이미지 출처 : [위키피디아](https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%83%9D) ><br><br>



#### 큐(Queue)

스택처럼 처음 입력된 것 부터 쌓이는것은 같으나 처음 들어온 녀석이 먼저 종료가 되는 방식이다 (First-In First-Out)
큐에서도 여러가지가 있기는 하나 우선 순위에 의해서 나중에 들어온 녀석이 종료되는 경우도 있다. 

<br>
![선형 Queue](https://drive.google.com/uc?id=0B0K0Mz4r_akrTTNSbERVSlpLb2M){: width="500", heigth="118"}<br>
< 선형 Queue / 자료출처 : [DZone](https://dzone.com/articles/algorithm-week-stack-and-queue) ><br><br>

큐에도 사실 종류가 2가지 가 있다 선형 큐와 원형 큐로 이야기를 하는데
선형 큐(혹은 막대큐) 의 문제점을 보완하기 위해서 원형큐가 이야기가 나온다.

기존의 선형 큐는 자료가 나갈때 한정된 공간이므로 자료의 위치를 이동 시키지않는 한은 계속 이동을 시켜줘야한다.
* 앞을 front 뒤를  rare 라고 표현을 한다

선형큐는 자료가 나갈때 포화상태를 확인하기 위해서 rare 를 확인하게 되는데 앞자리가 비었지만 포화상태인지를 모른다는 것이다. 그렇기 때문에 원형 큐를 사용한다.

<br>
![원형큐의 삽입과 삭제](https://drive.google.com/uc?id=0B0K0Mz4r_akrVDRmZThIVmlLOVk){: width="638", heigth="479"}<br>
< 원형큐의 삽입과 삭제 / 자료 출처 : [Slideshare](http://www.slideshare.net/ssuserff7918/ss) ><br><br>


#### 덱(Dequeue : Double-ended Queue)

덱은 스택과 큐를 합쳐 놓은 것이다. 규칙에 의해서 결정이 되겠지만 먼저들어와서 먼저 나갈수도 나중에 들어 녀석이 들어 수도 있다.<br>

![트리 구조](https://drive.google.com/uc?id=0B0K0Mz4r_akreTl2ZWluY0lFNUE){: width="322", heigth="309"}<br>
< 스택, 큐, 덱 / 자료 출처 : [블로그스팟](http://androidspeaksjava.blogspot.kr/2012/06/java-program-for-double-ended.html) ><br><br>


### 비선형

#### 트리

하나에서 계속 파생이 되는 형태이다<br>
![트리 구조](https://drive.google.com/uc?id=0B0K0Mz4r_akrWDVIbmRHa1hYOUk){: width="638", heigth="479"}<br>
< 트리 구조 / 자료출처 : [블로그  C언어 예술가](http://thrillfighter.tistory.com/225) ><br><br>

제일 상위에 있는 녀석을 루트라고 하고 각각 하나당 노드라고 불린다.

루트노드에서 계속 파생이 되는 형태이며 마치 트리모양과 비슷하다고 하여 트리구조라고 불리운다.


#### 그래프

트리는 하나에서 여러개가 파생이 되지만 이 구조는 전체가 다 연결이 되어 있다 (그물망 처럼 얽혀있다)

루트가 어디서 시작 되는 기준이 없다. 다 연결이 되어 있기 때문에 
 * 그래프가 어디서 활용이 되나 이야기 되는 부분은 페이스북의 친구 연결이 그래프 구조로 되어 있다고 한다.
   그래프 자료구조 개념에서 가장중요한건 다이나믹프로그래밍까지 들어가야 하는데 매우 복잡하므로 이런게 있다라는것만 소개하려 한다.

![트위터 팔로우 그래프 구조](https://drive.google.com/uc?id=0B0K0Mz4r_akrenFsSk8yUU5EY0E){: width="599", heigth="396"}<br>
< 트위터 팔로우 그래프 구조 / 자료출처 : [김민장님 블로그](http://egloos.zum.com/minjang/v/2995942) >


# 알고리즘

알고리즘은 컴퓨터 프로그래밍을 하는 것에 있어서 필수 요소이다.
위키피디아에는 이렇게 정의가 되어 있다. 
** "어떠한 문제를 해결하기 위한 여러 동작들의 모임" **


알고리즘이라는 정의는 간단하지만 사실은 생각보다 어렵다.

알고리즘 문제들이 어떤것들이 있나를 해보고 싶다면 아래 링크의 사이트에서 해보길 바란다.

[https://www.acmicpc.net](https://www.acmicpc.net) (최백준 님 Baekjoon Online Judge )

해당 글에서는 이러한 것들이 있다라는 소개로써 마무리를 지으려고 한다. 만약 추가적인 사항으로 공부하게 되어서 나오게 된다면 별도로 링크를 걸수 있도록 하겠습니다.


## 정렬 알고리즘

### 선택

{% youtube_mute 92BfuxHn2XE %}

좌에서 우로 움직이면서 가장 낮은 것을 먼저 앞에 하나씩 쌓는다.


### 버블
{% youtube_mute Cq7SMsQBEUw %}

선택과는 반대로 가장 큰 것을 찾아서 뒤부터 쌓아내려 온다.


### 삽입
{% youtube_mute 8oJS1BMKE64 %}
좌에서 부터 작은것과 큰것을 비교해서 삽입 하면서 진행 되어나가는 방식

### 병합
{% youtube_mute ZRPoEKHXTJg %}


### 퀵
{% youtube_mute 8hEyhs3OV1w %}
가장 빠른 정렬이라고 하여 퀵정렬이라고 불리운다.


<table>
    <tr>
        <td>{% youtube_mute KCoQ0P6ABqY %}</td>
        <td>버블<br><br>선택<br><br>삽입<br><br>셸<br><br>힙<br><br>퀵</td>
    </tr>
</table><br>


위에 해당하는 알고리즘은 정렬을 하면서 가장 최적화 된 부분을 찾는 부분이다.
상황에 따라서 퀵정렬이 빠를수도 안빠를수도 있다는 것이다.


## 알고리즘 의 성능

- 시간복잡도 : 알고리즘 수행시간 분석결과
- 공간복잡도 : 알고리즘 메모리 사용량에 대한 분석결과

### 빅오표기법 혹은 빅오복잡도(Big O Complexity)
 : 최악을 성능을 표시하여 준다. ( 이 외에도 2개의 표기법이 있으나 아무리 최악의 성능이라도 이정도의 성능은 보장한다는 의미로 많이 쓰인다.)

![빅오 복잡도](https://drive.google.com/uc?id=0B0K0Mz4r_akraEt5Si1mWWFheEU){: width="", height=""}<br>
<빅오 복잡도 / 출처 : [http://bigocheatsheet.com](http://bigocheatsheet.com)>   y는 시간 x는 데이터이다.<br><br>


- O(1) : 입력되는 양에 상관없이 일정한 시간을 가진다.

- O(N) : 데이터와 시간에 비례한다.

- O(N^2) : 데이터양에 따라 시간은 제곱에 비례한다. 
            : 시간에 비례하여 데이터양은 2의 N제곱이 된다.

- O(logN) : 데이터 양이 많아도 시간은 조금씩 늘어난다.

- O(NlogN) : 데이터양이 N배 할수록 , 시간은 N배보다 조그 더 늘어난다.(정비례하지 않음)


 * 그외 표현 
  오메가(Ω) : 최고의 성능을 표시해준다.
  세타 (Θ): 정확한 알고리즘의 성능을 표시해준다.

**  죄송합니다 빅오표기법과 알고리즘에 대해서는 제가 공부가 많이 부족해서 정확하게 표현을 못하겠습니다. 
     그렇기 때문에 그래프와 설명을 통해서 조금이나마 글을 남겨 놓습니다. 
     해당부분은 추후 더 공부해서 블로그글을 게시하도록 하겠습니다.


## 참고 자료 링크

 - 큐(Queue) [http://songeunjung92.tistory.com/23](http://songeunjung92.tistory.com/23)
 - 트리(Tree) [http://warmz.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%8A%B8%EB%A6%ACTree](http://warmz.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%8A%B8%EB%A6%ACTree)
 - 그래프 [http://egloos.zum.com/printf/v/755618](http://egloos.zum.com/printf/v/755618)
 - 빅오
    - 1) [http://www.mydiyworld.net/?p=440](http://egloos.zum.com/printf/v/755618)
    - 2) [http://stunstun.tistory.com/83](http://stunstun.tistory.com/83)

\* 위의 링크는 공부하시는데 조금 더 도움 되라고 걸어놓은 링크 자료 입니다. 